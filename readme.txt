

Disclosure: An LLM (specifically Claude) was used in implementing most the code in this repository, with varying levels of micromanagement, intervention, and debugging on my part.

This is a graph-based file management system (not anything as impressive as a filesystem) that I cobbled together for my own use after getting sufficiently tired of certain limitations of the traditional file management solutions for MacOS.  It is based on symlinks and thus is thus compatibility with a wide variety of existing software but, unlike symlinks, it is immune to the breakage issue that plagues the use of symlinks in frequently changing directory structures.

Traditionally, directories are organized in a tree-like manner, where a directory can have multiple child directories but only one parent directory, and furthermore, a directory cannot be reached from itself via its child directories.  This is very constrained — excessively constrained, even — for optimal user experience, as domains of knowledge and pursuit are not organized in a neat, hierarchical fashion, but the same things can appear in many different places, and things can be related to one another in a reciprocal manner.  A tree fails to capture this.

MacOS does provide some partial workarounds in the form of symlinks and aliases, but these have serious limitations of their own.  For symlinks, if the target of a symlink is moved, the symlink breaks.  Thus, symlinks provide non-hierarchicality at the cost of severely constraining the user's ability to safely rearrange their files.  Aliases are somewhat more robust than symlinks in regard to movement of the target as they keep track of the target's path and its inode instead of just its path, but can still be broken by routine operations, such as replacing the target with a copy of the same name and then moving it.  In addition, aliases are compatible with far fewer tools and applications than symlinks are; for example, the `cd` terminal command does not work with aliases, and at the time of this writing, VSCode does not support aliases in the file explorer and treats them as opaque files rather than as links to directories.

The solution here is based on symlinks but sidesteps its fragility limitation by making use of the following observation.  Given a directory, one can move the directory and break symlinks to it; meanwhile, given a symlink to a directory, one can move or rename the symlink, but this will not affect the directory itself and will therefore not break symlinks to it.  Thus, if the user relates and organizes files only through their symlinks and not through direct containment, the breakage issues can be avoided.

There is a GRAPH directory somewhere in the user's filesystem (with the location determined by an environment variable).  The directories directly contained in GRAPH, in the parlance of the collection of tools in this repository, are called “nodes”, and symlinks contained in nodes and targeting other nodes are called “edges”.  Rather than attempting to produce structure by nesting nodes directly inside of other nodes, one simply creates edges between nodes.  The user does not interact directly with GRAPH, but rather, enters the structure though a special GRAPH_ROOT node and navigates by traversing edges.  Edges can be moved, renamed, created, and deleted without risking any kind of breakage because no actual directories are being moved.
